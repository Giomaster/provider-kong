// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DestinationsInitParameters struct {

	// (String)
	IP *string `json:"ip,omitempty" tf:"ip,omitempty"`

	// (Number)
	Port *int64 `json:"port,omitempty" tf:"port,omitempty"`
}

type DestinationsObservation struct {

	// (String)
	IP *string `json:"ip,omitempty" tf:"ip,omitempty"`

	// (Number)
	Port *int64 `json:"port,omitempty" tf:"port,omitempty"`
}

type DestinationsParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	IP *string `json:"ip,omitempty" tf:"ip,omitempty"`

	// (Number)
	// +kubebuilder:validation:Optional
	Port *int64 `json:"port,omitempty" tf:"port,omitempty"`
}

type RouteInitParameters struct {

	// (Number) Unix epoch when the resource was created.
	// Unix epoch when the resource was created.
	CreatedAt *float64 `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// (Attributes List) A list of IP destinations of incoming connections that match this Route when using stream routing. Each entry is an object with fields "ip"  and/or "port". (see below for nested schema)
	Destinations []DestinationsInitParameters `json:"destinations,omitempty" tf:"destinations,omitempty"`

	// (Number) The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is HTTP instead of HTTPS. Location header is injected by Kong if the field is set to 301, 302, 307 or 308. Note: This config applies only if the Route is configured to only accept the https protocol. must be one of ["426", "301", "302", "307", "308"]
	// The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is `HTTP` instead of `HTTPS`. `Location` header is injected by Kong if the field is set to 301, 302, 307 or 308. Note: This config applies only if the Route is configured to only accept the `https` protocol. must be one of ["426", "301", "302", "307", "308"]
	HTTPSRedirectStatusCode *float64 `json:"httpsRedirectStatusCode,omitempty" tf:"https_redirect_status_code,omitempty"`

	// (Map of List of String) One or more lists of values indexed by header name that will cause this Route to match if present in the request. The Host header cannot be used with this attribute: hosts should be specified using the hosts attribute. When headers contains only one value and that value starts with the special prefix ~*, the value is interpreted as a regular expression.
	// One or more lists of values indexed by header name that will cause this Route to match if present in the request. The `Host` header cannot be used with this attribute: hosts should be specified using the `hosts` attribute. When `headers` contains only one value and that value starts with the special prefix `~*`, the value is interpreted as a regular expression.
	Headers map[string][]*string `json:"headers,omitempty" tf:"headers,omitempty"`

	// (List of String) A list of domain names that match this Route. Note that the hosts value is case sensitive.
	// A list of domain names that match this Route. Note that the hosts value is case sensitive.
	Hosts []*string `json:"hosts,omitempty" tf:"hosts,omitempty"`

	// (List of String) A list of HTTP methods that match this Route.
	// A list of HTTP methods that match this Route.
	Methods []*string `json:"methods,omitempty" tf:"methods,omitempty"`

	// (String) The name of the Route. Route names must be unique, and they are case sensitive. For example, there can be two different Routes named "test" and "Test".
	// The name of the Route. Route names must be unique, and they are case sensitive. For example, there can be two different Routes named "test" and "Test".
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) Controls how the Service path, Route path and requested path are combined when sending a request to the upstream. See above for a detailed description of each behavior. must be one of ["v0", "v1"]
	// Controls how the Service path, Route path and requested path are combined when sending a request to the upstream. See above for a detailed description of each behavior. must be one of ["v0", "v1"]
	PathHandling *string `json:"pathHandling,omitempty" tf:"path_handling,omitempty"`

	// (List of String) A list of paths that match this Route.
	// A list of paths that match this Route.
	Paths []*string `json:"paths,omitempty" tf:"paths,omitempty"`

	// (Boolean) When matching a Route via one of the hosts domain names, use the request Host header in the upstream request headers. If set to false, the upstream Host header will be that of the Service's host.
	// When matching a Route via one of the `hosts` domain names, use the request `Host` header in the upstream request headers. If set to `false`, the upstream `Host` header will be that of the Service's `host`.
	PreserveHost *bool `json:"preserveHost,omitempty" tf:"preserve_host,omitempty"`

	// (List of String) An array of the protocols this Route should allow. See the Route Object section for a list of accepted protocols. When set to only "https", HTTP requests are answered with an upgrade error. When set to only "http", HTTPS requests are answered with an error.
	// An array of the protocols this Route should allow. See the [Route Object](#route-object) section for a list of accepted protocols. When set to only `"https"`, HTTP requests are answered with an upgrade error. When set to only `"http"`, HTTPS requests are answered with an error.
	Protocols []*string `json:"protocols,omitempty" tf:"protocols,omitempty"`

	// regex routes is different (longer non-regex routes are matched before shorter ones).
	// A number used to choose which route resolves a given request when several routes match it using regexes simultaneously. When two routes match the path and have the same `regex_priority`, the older one (lowest `created_at`) is used. Note that the priority for non-regex routes is different (longer non-regex routes are matched before shorter ones).
	RegexPriority *float64 `json:"regexPriority,omitempty" tf:"regex_priority,omitempty"`

	// (Boolean) Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding.
	// Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding.
	RequestBuffering *bool `json:"requestBuffering,omitempty" tf:"request_buffering,omitempty"`

	// (Boolean) Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding.
	// Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding.
	ResponseBuffering *bool `json:"responseBuffering,omitempty" tf:"response_buffering,omitempty"`

	// (Attributes) The Service this Route is associated to. This is where the Route proxies traffic to. (see below for nested schema)
	Service *ServiceInitParameters `json:"service,omitempty" tf:"service,omitempty"`

	// (List of String) A list of SNIs that match this Route when using stream routing.
	// A list of SNIs that match this Route when using stream routing.
	Snis []*string `json:"snis,omitempty" tf:"snis,omitempty"`

	// (Attributes List) A list of IP sources of incoming connections that match this Route when using stream routing. Each entry is an object with fields "ip"  and/or "port". (see below for nested schema)
	Sources []SourcesInitParameters `json:"sources,omitempty" tf:"sources,omitempty"`

	// (Boolean) When matching a Route via one of the paths, strip the matching prefix from the upstream request URL.
	// When matching a Route via one of the `paths`, strip the matching prefix from the upstream request URL.
	StripPath *bool `json:"stripPath,omitempty" tf:"strip_path,omitempty"`

	// (List of String) An optional set of strings associated with the Route for grouping and filtering.
	// An optional set of strings associated with the Route for grouping and filtering.
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// (Number) Unix epoch when the resource was last updated.
	// Unix epoch when the resource was last updated.
	UpdatedAt *float64 `json:"updatedAt,omitempty" tf:"updated_at,omitempty"`
}

type RouteObservation struct {

	// (Number) Unix epoch when the resource was created.
	// Unix epoch when the resource was created.
	CreatedAt *float64 `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// (Attributes List) A list of IP destinations of incoming connections that match this Route when using stream routing. Each entry is an object with fields "ip"  and/or "port". (see below for nested schema)
	Destinations []DestinationsObservation `json:"destinations,omitempty" tf:"destinations,omitempty"`

	// (Number) The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is HTTP instead of HTTPS. Location header is injected by Kong if the field is set to 301, 302, 307 or 308. Note: This config applies only if the Route is configured to only accept the https protocol. must be one of ["426", "301", "302", "307", "308"]
	// The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is `HTTP` instead of `HTTPS`. `Location` header is injected by Kong if the field is set to 301, 302, 307 or 308. Note: This config applies only if the Route is configured to only accept the `https` protocol. must be one of ["426", "301", "302", "307", "308"]
	HTTPSRedirectStatusCode *float64 `json:"httpsRedirectStatusCode,omitempty" tf:"https_redirect_status_code,omitempty"`

	// (Map of List of String) One or more lists of values indexed by header name that will cause this Route to match if present in the request. The Host header cannot be used with this attribute: hosts should be specified using the hosts attribute. When headers contains only one value and that value starts with the special prefix ~*, the value is interpreted as a regular expression.
	// One or more lists of values indexed by header name that will cause this Route to match if present in the request. The `Host` header cannot be used with this attribute: hosts should be specified using the `hosts` attribute. When `headers` contains only one value and that value starts with the special prefix `~*`, the value is interpreted as a regular expression.
	Headers map[string][]*string `json:"headers,omitempty" tf:"headers,omitempty"`

	// (List of String) A list of domain names that match this Route. Note that the hosts value is case sensitive.
	// A list of domain names that match this Route. Note that the hosts value is case sensitive.
	Hosts []*string `json:"hosts,omitempty" tf:"hosts,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (List of String) A list of HTTP methods that match this Route.
	// A list of HTTP methods that match this Route.
	Methods []*string `json:"methods,omitempty" tf:"methods,omitempty"`

	// (String) The name of the Route. Route names must be unique, and they are case sensitive. For example, there can be two different Routes named "test" and "Test".
	// The name of the Route. Route names must be unique, and they are case sensitive. For example, there can be two different Routes named "test" and "Test".
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) Controls how the Service path, Route path and requested path are combined when sending a request to the upstream. See above for a detailed description of each behavior. must be one of ["v0", "v1"]
	// Controls how the Service path, Route path and requested path are combined when sending a request to the upstream. See above for a detailed description of each behavior. must be one of ["v0", "v1"]
	PathHandling *string `json:"pathHandling,omitempty" tf:"path_handling,omitempty"`

	// (List of String) A list of paths that match this Route.
	// A list of paths that match this Route.
	Paths []*string `json:"paths,omitempty" tf:"paths,omitempty"`

	// (Boolean) When matching a Route via one of the hosts domain names, use the request Host header in the upstream request headers. If set to false, the upstream Host header will be that of the Service's host.
	// When matching a Route via one of the `hosts` domain names, use the request `Host` header in the upstream request headers. If set to `false`, the upstream `Host` header will be that of the Service's `host`.
	PreserveHost *bool `json:"preserveHost,omitempty" tf:"preserve_host,omitempty"`

	// (List of String) An array of the protocols this Route should allow. See the Route Object section for a list of accepted protocols. When set to only "https", HTTP requests are answered with an upgrade error. When set to only "http", HTTPS requests are answered with an error.
	// An array of the protocols this Route should allow. See the [Route Object](#route-object) section for a list of accepted protocols. When set to only `"https"`, HTTP requests are answered with an upgrade error. When set to only `"http"`, HTTPS requests are answered with an error.
	Protocols []*string `json:"protocols,omitempty" tf:"protocols,omitempty"`

	// regex routes is different (longer non-regex routes are matched before shorter ones).
	// A number used to choose which route resolves a given request when several routes match it using regexes simultaneously. When two routes match the path and have the same `regex_priority`, the older one (lowest `created_at`) is used. Note that the priority for non-regex routes is different (longer non-regex routes are matched before shorter ones).
	RegexPriority *float64 `json:"regexPriority,omitempty" tf:"regex_priority,omitempty"`

	// (Boolean) Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding.
	// Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding.
	RequestBuffering *bool `json:"requestBuffering,omitempty" tf:"request_buffering,omitempty"`

	// (Boolean) Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding.
	// Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding.
	ResponseBuffering *bool `json:"responseBuffering,omitempty" tf:"response_buffering,omitempty"`

	// (Attributes) The Service this Route is associated to. This is where the Route proxies traffic to. (see below for nested schema)
	Service *ServiceObservation `json:"service,omitempty" tf:"service,omitempty"`

	// (List of String) A list of SNIs that match this Route when using stream routing.
	// A list of SNIs that match this Route when using stream routing.
	Snis []*string `json:"snis,omitempty" tf:"snis,omitempty"`

	// (Attributes List) A list of IP sources of incoming connections that match this Route when using stream routing. Each entry is an object with fields "ip"  and/or "port". (see below for nested schema)
	Sources []SourcesObservation `json:"sources,omitempty" tf:"sources,omitempty"`

	// (Boolean) When matching a Route via one of the paths, strip the matching prefix from the upstream request URL.
	// When matching a Route via one of the `paths`, strip the matching prefix from the upstream request URL.
	StripPath *bool `json:"stripPath,omitempty" tf:"strip_path,omitempty"`

	// (List of String) An optional set of strings associated with the Route for grouping and filtering.
	// An optional set of strings associated with the Route for grouping and filtering.
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// (Number) Unix epoch when the resource was last updated.
	// Unix epoch when the resource was last updated.
	UpdatedAt *float64 `json:"updatedAt,omitempty" tf:"updated_at,omitempty"`
}

type RouteParameters struct {

	// (Number) Unix epoch when the resource was created.
	// Unix epoch when the resource was created.
	// +kubebuilder:validation:Optional
	CreatedAt *float64 `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// (Attributes List) A list of IP destinations of incoming connections that match this Route when using stream routing. Each entry is an object with fields "ip"  and/or "port". (see below for nested schema)
	// +kubebuilder:validation:Optional
	Destinations []DestinationsParameters `json:"destinations,omitempty" tf:"destinations,omitempty"`

	// (Number) The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is HTTP instead of HTTPS. Location header is injected by Kong if the field is set to 301, 302, 307 or 308. Note: This config applies only if the Route is configured to only accept the https protocol. must be one of ["426", "301", "302", "307", "308"]
	// The status code Kong responds with when all properties of a Route match except the protocol i.e. if the protocol of the request is `HTTP` instead of `HTTPS`. `Location` header is injected by Kong if the field is set to 301, 302, 307 or 308. Note: This config applies only if the Route is configured to only accept the `https` protocol. must be one of ["426", "301", "302", "307", "308"]
	// +kubebuilder:validation:Optional
	HTTPSRedirectStatusCode *float64 `json:"httpsRedirectStatusCode,omitempty" tf:"https_redirect_status_code,omitempty"`

	// (Map of List of String) One or more lists of values indexed by header name that will cause this Route to match if present in the request. The Host header cannot be used with this attribute: hosts should be specified using the hosts attribute. When headers contains only one value and that value starts with the special prefix ~*, the value is interpreted as a regular expression.
	// One or more lists of values indexed by header name that will cause this Route to match if present in the request. The `Host` header cannot be used with this attribute: hosts should be specified using the `hosts` attribute. When `headers` contains only one value and that value starts with the special prefix `~*`, the value is interpreted as a regular expression.
	// +kubebuilder:validation:Optional
	Headers map[string][]*string `json:"headers,omitempty" tf:"headers,omitempty"`

	// (List of String) A list of domain names that match this Route. Note that the hosts value is case sensitive.
	// A list of domain names that match this Route. Note that the hosts value is case sensitive.
	// +kubebuilder:validation:Optional
	Hosts []*string `json:"hosts,omitempty" tf:"hosts,omitempty"`

	// (List of String) A list of HTTP methods that match this Route.
	// A list of HTTP methods that match this Route.
	// +kubebuilder:validation:Optional
	Methods []*string `json:"methods,omitempty" tf:"methods,omitempty"`

	// (String) The name of the Route. Route names must be unique, and they are case sensitive. For example, there can be two different Routes named "test" and "Test".
	// The name of the Route. Route names must be unique, and they are case sensitive. For example, there can be two different Routes named "test" and "Test".
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) Controls how the Service path, Route path and requested path are combined when sending a request to the upstream. See above for a detailed description of each behavior. must be one of ["v0", "v1"]
	// Controls how the Service path, Route path and requested path are combined when sending a request to the upstream. See above for a detailed description of each behavior. must be one of ["v0", "v1"]
	// +kubebuilder:validation:Optional
	PathHandling *string `json:"pathHandling,omitempty" tf:"path_handling,omitempty"`

	// (List of String) A list of paths that match this Route.
	// A list of paths that match this Route.
	// +kubebuilder:validation:Optional
	Paths []*string `json:"paths,omitempty" tf:"paths,omitempty"`

	// (Boolean) When matching a Route via one of the hosts domain names, use the request Host header in the upstream request headers. If set to false, the upstream Host header will be that of the Service's host.
	// When matching a Route via one of the `hosts` domain names, use the request `Host` header in the upstream request headers. If set to `false`, the upstream `Host` header will be that of the Service's `host`.
	// +kubebuilder:validation:Optional
	PreserveHost *bool `json:"preserveHost,omitempty" tf:"preserve_host,omitempty"`

	// (List of String) An array of the protocols this Route should allow. See the Route Object section for a list of accepted protocols. When set to only "https", HTTP requests are answered with an upgrade error. When set to only "http", HTTPS requests are answered with an error.
	// An array of the protocols this Route should allow. See the [Route Object](#route-object) section for a list of accepted protocols. When set to only `"https"`, HTTP requests are answered with an upgrade error. When set to only `"http"`, HTTPS requests are answered with an error.
	// +kubebuilder:validation:Optional
	Protocols []*string `json:"protocols,omitempty" tf:"protocols,omitempty"`

	// regex routes is different (longer non-regex routes are matched before shorter ones).
	// A number used to choose which route resolves a given request when several routes match it using regexes simultaneously. When two routes match the path and have the same `regex_priority`, the older one (lowest `created_at`) is used. Note that the priority for non-regex routes is different (longer non-regex routes are matched before shorter ones).
	// +kubebuilder:validation:Optional
	RegexPriority *float64 `json:"regexPriority,omitempty" tf:"regex_priority,omitempty"`

	// (Boolean) Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding.
	// Whether to enable request body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that receive data with chunked transfer encoding.
	// +kubebuilder:validation:Optional
	RequestBuffering *bool `json:"requestBuffering,omitempty" tf:"request_buffering,omitempty"`

	// (Boolean) Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding.
	// Whether to enable response body buffering or not. With HTTP 1.1, it may make sense to turn this off on services that send data with chunked transfer encoding.
	// +kubebuilder:validation:Optional
	ResponseBuffering *bool `json:"responseBuffering,omitempty" tf:"response_buffering,omitempty"`

	// (Attributes) The Service this Route is associated to. This is where the Route proxies traffic to. (see below for nested schema)
	// +kubebuilder:validation:Optional
	Service *ServiceParameters `json:"service,omitempty" tf:"service,omitempty"`

	// (List of String) A list of SNIs that match this Route when using stream routing.
	// A list of SNIs that match this Route when using stream routing.
	// +kubebuilder:validation:Optional
	Snis []*string `json:"snis,omitempty" tf:"snis,omitempty"`

	// (Attributes List) A list of IP sources of incoming connections that match this Route when using stream routing. Each entry is an object with fields "ip"  and/or "port". (see below for nested schema)
	// +kubebuilder:validation:Optional
	Sources []SourcesParameters `json:"sources,omitempty" tf:"sources,omitempty"`

	// (Boolean) When matching a Route via one of the paths, strip the matching prefix from the upstream request URL.
	// When matching a Route via one of the `paths`, strip the matching prefix from the upstream request URL.
	// +kubebuilder:validation:Optional
	StripPath *bool `json:"stripPath,omitempty" tf:"strip_path,omitempty"`

	// (List of String) An optional set of strings associated with the Route for grouping and filtering.
	// An optional set of strings associated with the Route for grouping and filtering.
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// (Number) Unix epoch when the resource was last updated.
	// Unix epoch when the resource was last updated.
	// +kubebuilder:validation:Optional
	UpdatedAt *float64 `json:"updatedAt,omitempty" tf:"updated_at,omitempty"`
}

type ServiceInitParameters struct {

	// (String) The ID of this resource.
	// +crossplane:generate:reference:type=github.com/Giomaster/provider-kong/apis/kong/v1alpha1.Service
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Reference to a Service in kong to populate id.
	// +kubebuilder:validation:Optional
	IDRef *v1.Reference `json:"idRef,omitempty" tf:"-"`

	// Selector for a Service in kong to populate id.
	// +kubebuilder:validation:Optional
	IDSelector *v1.Selector `json:"idSelector,omitempty" tf:"-"`
}

type ServiceObservation struct {

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type ServiceParameters struct {

	// (String) The ID of this resource.
	// +crossplane:generate:reference:type=github.com/Giomaster/provider-kong/apis/kong/v1alpha1.Service
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Reference to a Service in kong to populate id.
	// +kubebuilder:validation:Optional
	IDRef *v1.Reference `json:"idRef,omitempty" tf:"-"`

	// Selector for a Service in kong to populate id.
	// +kubebuilder:validation:Optional
	IDSelector *v1.Selector `json:"idSelector,omitempty" tf:"-"`
}

type SourcesInitParameters struct {

	// (String)
	IP *string `json:"ip,omitempty" tf:"ip,omitempty"`

	// (Number)
	Port *int64 `json:"port,omitempty" tf:"port,omitempty"`
}

type SourcesObservation struct {

	// (String)
	IP *string `json:"ip,omitempty" tf:"ip,omitempty"`

	// (Number)
	Port *int64 `json:"port,omitempty" tf:"port,omitempty"`
}

type SourcesParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	IP *string `json:"ip,omitempty" tf:"ip,omitempty"`

	// (Number)
	// +kubebuilder:validation:Optional
	Port *int64 `json:"port,omitempty" tf:"port,omitempty"`
}

// RouteSpec defines the desired state of Route
type RouteSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RouteParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider RouteInitParameters `json:"initProvider,omitempty"`
}

// RouteStatus defines the observed state of Route.
type RouteStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RouteObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Route is the Schema for the Routes API. Route Resource
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,kong}
type Route struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RouteSpec   `json:"spec"`
	Status            RouteStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RouteList contains a list of Routes
type RouteList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Route `json:"items"`
}

// Repository type metadata.
var (
	Route_Kind             = "Route"
	Route_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Route_Kind}.String()
	Route_KindAPIVersion   = Route_Kind + "." + CRDGroupVersion.String()
	Route_GroupVersionKind = CRDGroupVersion.WithKind(Route_Kind)
)

func init() {
	SchemeBuilder.Register(&Route{}, &RouteList{})
}
